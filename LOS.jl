# LOS.jl

#=
 This file contains functions used by julia files generated by pWhile 
 compiler. Most of the naming conventions used in this file are 
 inspired by the paper `Probabilistic Semantics and Program Analysis` 
 by A.D.Pierro, C.Hankin and H.Wiklicky. Some references to this paper
 are also made throught the comments in this code.
 
=#

#--------------------------------------------------------------------
# Auxiliary functions
#--------------------------------------------------------------------

"""
    I(dim)  

Return sparse identity matrix of dimension `dim`
"""
function I(dim)
  return speye(Int,dim)
end

"""
    E(m, n, i, j)

Return sparse `m` by `n` matrix with `ij`-entry 1, others 0
"""
function E(m, n, i, j)
  @assert valid_index(m, i) && valid_index(n, j)
  R = spzeros(Int,m,n)
  R[i,j] = 1
  return R
end

"""
    E(dim, i, j)

Return sparse square matrix with `ij`-entry 1, others 0, dimension `dim`
"""
function E(dim, i, j)
  @assert valid_index(dim, i) && valid_index(dim, j)
  R = spzeros(Int,dim, dim)
  R[i,j] = 1
  return R
end

"""
    E(dim, i)

Return sparse matrix with `i`th diagonal entry 1, others 0, dimension `dim`
"""
function E(dim, i)
  return E(dim, i , i)
end

"""
    U_c(dim,c)

Return sparse square matrix of dimension `dim` with entries
in `c`th column 1, otherwise 0
"""
function U_c(dim,c) 
  @assert valid_index(dim, c)
  R = spzeros(Int,dim,dim)
  for i = 1:dim
    R[i,c] = 1
  end
  return R
end

"""
    e_i(dim,i)

Return a vector of dimension `dim` (ie a 1x`dim` matrix) with a one at 
position `i`, zeros otheriwse
"""
function e_i(dim,i)
  @assert valid_index(dim, i)
  R = spzeros(Int,1,dim)
  R[i] = 1
  return R
end

"""
    findall(lookedfor, target)

Find all indices of elements from 'lookedfor' in 'target'

# Examples
```julia 
julia> findall([1,3], [1,2,3,4])
2-element Array{Any,1}:
 1
 3

julia> findall([2,3,4],[1,3,5])
1-element Array{Any,1}:
 2
```
"""
# NOT USED CURRENTLY - USED ONLY WHEN Ur USED
function findall(lookedfor, target)
  @assert issorted(lookedfor) && issorted(target)
  i, j = 1, 1
  result = []
  while i <= length(lookedfor) && lookedfor[i] <= target[end]
    if lookedfor[i] > target[j]
      j += 1
    elseif lookedfor[i] < target[j]
      i += 1
    else 
      push!(result, j)
      i += 1
      j += 1
    end
  end
  result
end


#=
State of variables in a program can be represented twofold.
Firstly, it could be an array specifying value of each variable
(i.e. value of ith variable is at position i in the array) - this 
is the representation described in the paper.
Alternatively, it could be represented by a single integer value 
between 1 and d (inclusive), where d is the number of different states.
Now clearly there's an isomorphism between the two representations.

# Example
Suppose there are two variables, x and y, both can take 2 different values
(it doesn't matter what those values are). Then the isomorphism is:
```julia
                        [1,1] <-> 1
                        [1,2] <-> 2
                        [2,1] <-> 3
                        [2,2] <-> 4
```
index and unindex provide the mapping between the two representations.
  - index tranforms state represented by array of values of variables into
    state represented by an integer 
  - unindex does the opposite
=#

"""
    unindex(dims, i)

Return array representation of the state of the variables corresponding
to the integer representation `i`

# Example
```julia
julia> unindex([2,2], 3)
2-element Array{Int64,1}:
 2
 1
```
"""
function unindex(dims::Array{Int,1}, i::Int) 
  @assert i <= prod(dims)
  result::Array{Int,1} = []
  if length(dims) > 1
    result = unindex(dims[1:end-1] ,div(i - 1, dims[end]) + 1)
  end
  push!(result, rem(i - 1, dims[end]) + 1)
  return result
end

"""
    index(dims, values)

Return integer representation of the state of the variables corresponding
to the array representation `values`

# Example
```julia
julia> index([2,2], [2,1])
 3
```
"""
function index(dims::Array{Int,1}, values::Array{Int,1})
  @assert length(dims) == length(values)
  for i=1:length(dims)
    @assert dims[i] >= values[i]
  end
  if length(dims) == 1
    return values[1]
  else 
    return (values[1] - 1) * prod(dims[2:end]) + index(dims[2:end], values[2:end])
  end
end

function valid_index(dim, i)
  return i > 0 && i <= dim
end

"""
    swap_array(ordinals)

Return the array of 'swaps', which is a permutation of `ordinals` 
that maximizes number of positions `i`

# Example
```julia
julia> swap_array([2,4,6,7])
4-element Array{Int64,1}:
 6
 2
 7
 4
```
"""
function swap_array(ordinals::Array{Int,1})
  n = length(ordinals)
  a = fill(0, (1,n))
  min = 1
  for i in ordinals
    if i <= n 
      a[i] = i
    else
      while a[min] != 0
        min += 1
      end
      a[min] = i
    end
  end
  return a
end

function swap!(arr, i, j)
  @assert valid_index(length(arr), i) && valid_index(length(arr), j)
  if i != j
    arr[i], arr[j] = arr[j], arr[i] 
  end
end

function compute_swaps(ordinals::Array{Int,1})
  result = sort(union(ordinals))
  n = length(result)
  for i = n:-1:1
    if result[i] <= n && result[i] != i
      swap!(result, i, result[i])
    end
  end
  return result
end

function compute_swapped_dims(dims::Array{Int,1}, swaps::Array{Int,1})
  result = copy(dims)
  for i = 1:length(swaps)
    swap!(result, i, swaps[i])
  end
  return result
end

function extend(values::Array{Int,1}, ordinals::Array{Int,1}, n::Int) 
  for i in ordinals
    @assert i <= n
  end
  result = squeeze(ones(Int,1,n),1)
  for i = 1:length(ordinals)
    result[ordinals[i]] = values[i]
  end
  return result
end

function compute_swap_operator(dims, p, q)
  @assert valid_index(length(dims), p) && valid_index(length(dims), q)
  d = prod(dims)
  if p == q
    return I(d)
  end
  R = spzeros(Int,d,d)
  for i = 1:dims[p]
    for j = 1:dims[q]
      A = I(1)
      for k = 1:p-1
        A = kron(A,I(dims[k]))
      end
      A = kron(A,E(dims[p],dims[q],i,j))
      for k = p+1:q-1
        A = kron(A,I(dims[k]))
      end
      A = kron(A,transpose(E(dims[p],dims[q],i,j))) 
      for k = q+1:length(dims)
        A = kron(A,I(dims[k]))
      end
      R += A
    end
  end
  return R
end

function compute_swaps_operator(dims::Array{Int,1}, swaps::Array{Int,1})
  R = I(prod(dims))
  for i = 1:length(swaps)
    if i != swaps[i]
      R = R * compute_swap_operator(dims, i, swaps[i])
    end
  end
  return R
end

#--------------------------------------------------------------------
# State update operators and filter operators
#--------------------------------------------------------------------

function U_xk_c(dims, k, c) 
  @assert c > 0 && c <= dims[k]
  R = I(1)
  for i = 1:(k - 1)
    R = kron(R, I(dims[i]))
  end
  R = kron(R, U_c(dims[k],c))
  for i = (k + 1):length(dims)
    R = kron(R, I(dims[i]))
  end
  return R
end

function Ue(dims::Array{Int,1}, ordinal::Int, ordinals::Array{Int,1}, update::Function)
  swaps = compute_swaps(push!(copy(ordinals), ordinal))
  n = length(swaps)
  dims_swapped = compute_swapped_dims(dims, swaps)
  dims_restricted = dims_swapped[1:n]
  newordinal = findfirst(swaps, ordinal)
  d = prod(dims_restricted)
  R = spzeros(d,d)
  for i = 1:d
    values_restricted = unindex(dims_restricted, i)
    values = extend(values_restricted, swaps, length(dims))
    values_restricted[newordinal] = update(values)
    if values_restricted[newordinal] > 0
      R[i, index(dims_restricted, values_restricted)] = 1
    end
  end
  for dim in dims_swapped[n+1:end]
    R = kron(R,I(dim))
  end
  K = compute_swaps_operator(dims, swaps)
  return K * R * K 
end

# old update expression operator which doesnt take into account how many variables
# are involved in the expression
function Ue(dims::Array{Int,1}, ordinal::Int, update::Function)
  @assert ordinal <= length(dims)
  d = prod(dims)
  R = spzeros(d,d)
  for i = 1:d
    values = unindex(dims, i)
    values[ordinal] = update(values) # might be that the value computed here
                                     # falls out of range (so is 0)
    if values[ordinal] > 0
      R[i,index(dims, values)] = 1
    end
  end
  return R
end

function Ur(dims::Array{Int,1}, ordinal::Int, 
           range::Array{Int,1}, assign_range::Array{Int,1})
  d = prod(dims)
  values = findall(assign_range, range)
  result = spzeros(d,d)
  for i in values 
    result += Uc(dims, ordinal, i)
  end
  return 1//length(values) * result
end

function P(dims::Array{Int,1}, values::Array{Int,1}) 
  @assert length(dims) == length(values)
  R = I(1)
  for i = 1:length(dims)
    R = kron(R, E(dims[i], values[i]))
  end
  return R
end

function P(dims::Array{Int,1}, test::Function, c::Bool)
  d = prod(dims)
  R = spzeros(d,d)
  for i = 1:d
    values = unindex(dims, i)
    if test(values) == c
      R += P(dims, values)
    end
  end
  return R
end

1;
