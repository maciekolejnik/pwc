# LOS.jl

#=
 This file contains functions used by julia files generated by pWhile 
 compiler. Most of the naming conventions used in this file are 
 inspired by the paper `Probabilistic Semantics and Program Analysis` 
 by A.D.Pierro, C.Hankin and H.Wiklicky. Some references to this paper
 are also made throught the comments in this code.
 
=#

#--------------------------------------------------------------------
# Auxiliary functions
#--------------------------------------------------------------------

"""
    I(dim)  

Return sparse identity matrix of dimension `dim`
"""
function I(dim)
  return speye(Int,dim)
end

"""
    E(m, n, i, j)

Return sparse `m` by `n` matrix with `ij`-entry 1, others 0
"""
function E(m, n, i, j)
  @assert valid_index(m, i) && valid_index(n, j)
  R = spzeros(Int,m,n)
  R[i,j] = 1
  return R
end

"""
    E(dim, i, j)

Return sparse square matrix with `ij`-entry 1, others 0, dimension `dim`
"""
function E(dim, i, j)
  @assert valid_index(dim, i) && valid_index(dim, j)
  R = spzeros(Int,dim, dim)
  R[i,j] = 1
  return R
end

"""
    E(dim, i)

Return sparse matrix with `i`th diagonal entry 1, others 0, dimension `dim`
"""
function E(dim, i)
  return E(dim, i , i)
end

"""
    U_c(dim,c)

Return sparse square matrix of dimension `dim` with entries
in `c`th column 1, otherwise 0
"""
function U_c(dim,c) 
  @assert valid_index(dim, c)
  R = spzeros(Int,dim,dim)
  for i = 1:dim
    R[i,c] = 1
  end
  return R
end

"""
    e_i(dim,i)

Return a vector of dimension `dim` (ie a 1x`dim` matrix) with a one at 
position `i`, zeros otheriwse
"""
function e_i(dim,i)
  @assert valid_index(dim, i)
  R = spzeros(Int,1,dim)
  R[i] = 1
  return R
end

#=
State of variables in a program can be represented twofold.
Firstly, it could be an array specifying value of each variable
(i.e. value of ith variable is at position i in the array) - this 
is the representation described in the paper.
Alternatively, it could be represented by a single integer value 
between 1 and d (inclusive), where d is the number of different states.
Now clearly there's an isomorphism between the two representations.

# Example
Suppose there are two variables, x and y, both can take 2 different values
(it doesn't matter what those values are). Then the isomorphism is:
```julia
                        [1,1] <-> 1
                        [1,2] <-> 2
                        [2,1] <-> 3
                        [2,2] <-> 4
```
index and unindex provide the mapping between the two representations.
  - index tranforms state represented by array of values of variables into
    state represented by an integer 
  - unindex does the opposite
=#

"""
    unindex(dims, i)

Return array representation of the state of the variables corresponding
to the integer representation `i`

# Example
```julia
julia> unindex([2,2], 3)
2-element Array{Int64,1}:
 2
 1
```
"""
function unindex(dims::Array{Int,1}, i::Int) 
  @assert i <= prod(dims)
  result::Array{Int,1} = []
  if length(dims) > 1
    result = unindex(dims[1:end-1] ,div(i - 1, dims[end]) + 1)
  end
  push!(result, rem(i - 1, dims[end]) + 1)
  return result
end

"""
    index(dims, values)

Return integer representation of the state of the variables corresponding
to the array representation `values`

# Example
```julia
julia> index([2,2], [2,1])
 3
```
"""
function index(dims::Array{Int,1}, values::Array{Int,1})
  @assert length(dims) == length(values)
  for i=1:length(dims)
    @assert dims[i] >= values[i]
  end
  if length(dims) == 1
    return values[1]
  else 
    return (values[1] - 1) * prod(dims[2:end]) + index(dims[2:end], values[2:end])
  end
end

"""
    valid_index(len, i)

Check whether `i` is a valid index into a vector of length `len`

# Example
```julia
julia> valid_index(5,2)
true 

julia> valid_index(5,0)
false
```
"""
function valid_index(len, i)
  return i > 0 && i <= len
end

"""
    swap!(arr, i, j)

Swaps elements at positions `i` and `j` in an array `arr`, in place.
Assumes `i` and `j` are valid indexes into the array.

# Example
```julia
julia> arr = [1,2,3,4,5]
julia> swap!(arr,2,4)
julia> arr
5-element Array{Int64,1}:
 1
 4
 3
 2
 5
```
"""
function swap!(arr, i, j)
  @assert valid_index(length(arr), i) && valid_index(length(arr), j)
  if i != j
    arr[i], arr[j] = arr[j], arr[i] 
  end
end

"""
    compute_swaps(ordinals)

Given `ordinals` (of variables that appear in an arithmetic expression)
compute how variables need to be swapped to minimise the number of swaps.
Using the fact that variables will be swapped into positions 1,2,...,n, 
where n is length of `ordinals`, the swaps are represented as an array 
of length n. 

# Example
```julia
julia> compute_swaps([7,1,6,4])
4-element Array{Int64,1}:
 1
 7
 6
 4
```
Here the resulting array represents the swaps:
 (1 <=> 1)
  2 <=> 7
  3 <=> 6
 (4 <=> 4)

1 and 4 are in brackets since they don't represent actual swaps
"""
function compute_swaps(ordinals::Array{Int,1})
  result = sort(union(ordinals))
  n = length(result)
  for i = n:-1:1
    if result[i] <= n && result[i] != i
      swap!(result, i, result[i])
    end
  end
  return result
end

"""
    compute_swapped_dims(dims, swaps)

Given variable dimensions in the intial order `dims`, compute
the dimensions order after the swap represented by `swaps`
(so returned value is a permutation of `dims`)

# Example
```julia
julia> compute_swapped_dims([3,3,2,2], [3,4])
4-element Array{Int64,1}:
 2
 2
 3
 3
```
"""
function compute_swapped_dims(dims::Array{Int,1}, swaps::Array{Int,1})
  result = copy(dims)
  for i = 1:length(swaps)
    swap!(result, i, swaps[i])
  end
  return result
end

"""
    extend(values_restricted, ordinals, n)

Extend the restricted vector of variables values `values_restricted`
to a full vector of length `n`, where the values of variables with
ordinals in `ordinals` are specified in `values_restricted`. Other
values are set to 1.

# Example
```julia
julia> extend([3,2,4],[1,5,4],6)
6-element Array{Int64,1}:
 3
 1
 1
 4
 2
 1
```
"""
function extend(values_restricted::Array{Int,1}, swaps::Array{Int,1}, n::Int) 
  for i in swaps
    @assert i <= n
  end
  @assert length(values_restricted) == length(swaps)
  result = squeeze(ones(Int,1,n),1)
  for i = 1:length(swaps)
    result[swaps[i]] = values_restricted[i]
  end
  return result
end

"""
    compute_swap_operator(dims, p, q)

Compute operator (i.e. matrix) that swaps `p`th and `q`th variables
It is based on an idea of a commutator matrix which makes Kronecker
product commute. 

"""
function compute_swap_operator(dims::Array{Int,1}, p::Int, q::Int)
  @assert valid_index(length(dims), p) && valid_index(length(dims), q)
  d = prod(dims)
  if p == q
    return I(d)
  end
  R = spzeros(Int,d,d)
  for i = 1:dims[p]
    for j = 1:dims[q]
      A = I(1)
      for k = 1:p-1
        A = kron(A,I(dims[k]))
      end
      A = kron(A,E(dims[p],dims[q],i,j))
      for k = p+1:q-1
        A = kron(A,I(dims[k]))
      end
      A = kron(A,transpose(E(dims[p],dims[q],i,j))) 
      for k = q+1:length(dims)
        A = kron(A,I(dims[k]))
      end
      R += A
    end
  end
  return R
end

"""
    compute_swaps_operator(dims, swaps)

Compute operator (i.e. matrix) that swaps variables as represented by
`swaps` vector. It is the product of swap operators for each individual 
swap

"""
function compute_swaps_operator(dims::Array{Int,1}, swaps::Array{Int,1})
  R = I(prod(dims))
  for i = 1:length(swaps)
    if i != swaps[i]
        R = R * compute_swap_operator(dims, i, swaps[i])
    end
  end
  return R
end

#--------------------------------------------------------------------
# State update operators and filter operators
#--------------------------------------------------------------------
# 
# In all fuctions below dims is the vector of variable dimensions
#

"""
    U_xk_c(dims, k, c)

    Constant update operator

Compute operator that assigns `k`th variable value `c` 
(i.e. the `c`th value in its range - NOT RIGHT NOW), and leaves others
as they are

"""
function U_xk_c(dims::Array{Int,1}, ordinal::Int, c::Int) 
  R = I(1)
  for i = 1:(ordinal - 1)
    R = kron(R, I(dims[i]))
  end
  # TODO: possibly change for value out of range!
  if c > 0
    R = kron(R, U_c(dims[ordinal], c))
  else
    R = kron(R, spzeros(Int, dims[ordinal], dims[ordinal]))
  end
  for i = (ordinal + 1):length(dims)
    R = kron(R, I(dims[i]))
  end
  return R
end

#--------------------------------------------------------------------
# Update operators 
#--------------------------------------------------------------------

"""
    Ue(dims, ordinal, update)

    Variable update operator

Compute the operator that assigns to variable with ordinal `ordinal` 
the value of expression e, where the value, given values of variables,
is computed using the function `update`. This is the basic implementation
which doesn't take into account the number of variables appearing on 
the RHS of the assignment. 
It loops over all the possible combinations of variable values (and
uses `unindex` to recover those) and computes the value of the 
expression (using the `update` function) for those values of variables.

"""
function Ue(dims::Array{Int,1}, ordinal::Int, update::Function)
  @assert ordinal <= length(dims)
  d = prod(dims)
  R = spzeros(Int,d,d)
  for i = 1:d
    values = unindex(dims, i)
    values[ordinal] = update(values)  
    if values[ordinal] > 0
      R[i,index(dims, values)] = 1
    end
  end
  return R
end

"""
    Ue(dims, ordinal, ordinals, update)

    Optimised variable update operator

Compute the operator that assigns to variable with ordinal `ordinal` 
the value of expression e, where the value, given values of variables,
is computed using the function `update`. `ordinals` is the vector of 
ordinals of variables that appear on the RHS of the assignment.
With that, the operator can be computed more efficiently by
swapping involved variables so they come first, compute the smaller
update operator restricted to involved variables and compute 
Kronecker product of that operator with identity matrices representing
lack of influence of other variables on the current assignment.

Special case is when `ordinals` is empty - it means the expression
on the RHS of the assignment does not contain any variables, i.e. has
a numeric value. Hence constant update operator from above can be used.

"""
function Ue(dims::Array{Int,1}, ordinal::Int, 
            update::Function, ordinals::Array{Int,1})
  if length(ordinals) == 0
    values = ones(Int, 1, length(dims))
    return U_xk_c(dims, ordinal, update(values))
  end
  swaps = compute_swaps(push!(copy(ordinals), ordinal))
  n = length(swaps)
  dims_swapped = compute_swapped_dims(dims, swaps)
  dims_restricted = dims_swapped[1:n]
  newordinal = findfirst(swaps, ordinal)
  d = prod(dims_restricted)
  R = spzeros(Int,d,d)
  for i = 1:d
    values_restricted = unindex(dims_restricted, i)
    values = extend(values_restricted, swaps, length(dims))
    values_restricted[newordinal] = update(values)
    if values_restricted[newordinal] > 0
      R[i, index(dims_restricted, values_restricted)] = 1
    end
  end
  for dim in dims_swapped[n+1:end]
    R = kron(R,I(dim))
  end
  K = compute_swaps_operator(dims, swaps)
  return K * R * K 
end

#--------------------------------------------------------------------
# Array update operators 
#--------------------------------------------------------------------

"""
    Ua_c(dims, ordinal, compute_index, size, c)

    Constant array update operator

Compute operator that assigns value `c` to the kth element
of the array (of size `size`) that starts at ordinal `ordinal`, 
where k is computed given values of all variables by 
function `compute_index`.

"""
function Ua_c(dims::Array{Int,1}, ordinal::Int, compute_index::Function, 
              size::Int, c::Int)
  @assert ordinal <= length(dims)
  d = prod(dims)
  R = spzeros(Int,d,d)
  for i = 1:d
    values = unindex(dims, i)
    pos = compute_index(values) # TODO: handle the case of pos out of bounds properly
    if valid_index(size, pos + 1) 
      values[ordinal + pos] = c
      if values[ordinal + pos] > 0
        R[i,index(dims, values)] = 1
      end
    end
  end
  return R
end

"""
    Ua_c(dims, ordinal, compute_index, index_ordinals, size, c)

    Optimised constant array update operator

As above, but uses extra information in `index_ordinals` which tells
which variables appear in the index expression.
"""
function Ua_c(dims::Array{Int,1}, ordinal::Int, compute_index::Function, 
              index_ordinals::Array{Int,1}, size::Int, c::Int)
  @assert ordinal <= length(dims)
  d = prod(dims)
  R = spzeros(Int,d,d)
  for i = 0:size-1
    R += P(dims, compute_index, index_ordinals, i) * 
         U_xk_c(dims, ordinal + i, c) 
  end
  return R
end

"""
    Ua(dims, ordinal, compute_index, index_ordinals, 
       size, update, update_ordinals)

    Optimised array update operator

Compute the operator that assigns to nth element of an array of size
`size`, whose first element has ordinal `ordinal`, value given by 
function `update`, where n is given by function `compute_index` 
(which, the same as `update`, takes as argument values of all variables,
so n differs depending on the values of variables)
Uses the extra information in `index_ordinals` - which variables appear
in the index expression, and `update_ordinals` - which variables appear
in the RHS expression.
"""
function Ua(dims::Array{Int,1}, ordinal::Int, compute_index::Function, 
            index_ordinals::Array{Int,1}, size::Int, update::Function,
            update_ordinals::Array{Int,1})
  @assert ordinal <= length(dims)
  if length(index_ordinals) == 0
    index = compute_index([])
    # how to handle array index out of range?
    if valid_index(size, index + 1)
      return Ue(dims, ordinal + index, update, update_ordinals)
    end
  end
  d = prod(dims)
  R = spzeros(Int,d,d)
  for i = 0:size-1
    R += P(dims, compute_index, index_ordinals, i) * 
         Ue(dims, ordinal + i, update, update_ordinals) 
  end
  return R
end

"""
    Ua(dims, ordinal, compute_index, size, update)

    Array update operator

Compute the operator that assigns to nth element of an array of size
`size`, whose first element has ordinal `ordinal`, value given by 
function `update`, where n is given by function `compute_index` 
(which, the same as `update`, takes as argument values of all variables,
so n differs depending on the values of variables)
"""
function Ua(dims::Array{Int,1}, ordinal::Int, compute_index::Function, 
            size::Int, update::Function)
  @assert ordinal <= length(dims)
  d = prod(dims)
  R = spzeros(Int,d,d)
  for i = 1:d
    values = unindex(dims, i)
    pos = compute_index(values) # TODO: handle the case of pos out of bounds properly
    if valid_index(size, pos + 1) 
      values[ordinal + pos] = update(values)
      if values[ordinal + pos] > 0
        R[i,index(dims, values)] = 1
      end
    end
  end
  return R
end

function Ua_alt(dims::Array{Int,1}, ordinal::Int, compute_index::Function, 
                size::Int, update::Function)
  @assert ordinal <= length(dims)
  d = prod(dims)
  R = spzeros(Int,d,d)
  for i = 0:size-1
    R += P(dims, compute_index, i) * Ue(dims, ordinal + i, update) 
  end
  return R
end

#--------------------------------------------------------------------
# Filter operators 
#--------------------------------------------------------------------

# NOT USED
"""
    P(dims, values)

    Filter operator for a single state

Compute filter operator corresponding to the state in which 
variables values are given by `values`
"""
function P(dims::Array{Int,1}, values::Array{Int,1}) 
  @assert length(dims) == length(values)
  R = I(1)
  for i = 1:length(dims)
    R = kron(R, E(dims[i], values[i]))
  end
  return R
end

"""
    P(dims, ordinals, test, c) 

    Optimised filter operator

Compute the filter operator filtering states in which expression 'e'
evaluates to value `c`, where `c` is `true` or `false`. Function `test`
is used to evaluate the expression e given values of all variables.
It follows similar pattern as the optimised update operator, i.e. it
uses the vector of ordinals of variables that appear in the expression
'e' to restrict the computation of the filter operator to only those variables
and then naturally extend it to other variables using Kronecker product.
Special case here is when no variables appear in expression 'e' - then the
operator is simply identity when 'e' is true and zero matrix when 'e' is false
   
"""
function P(dims::Array{Int,1}, test::Function, ordinals::Array{Int,1}, c::Int)
  if length(ordinals) == 0
    values = squeeze(ones(Int,1,length(dims)),1)
    d = prod(dims)
    if test(values) == c
      return I(d)
    else
      return spzeros(Int,d,d)
    end
  end
  swaps = compute_swaps(ordinals)
  n = length(swaps)
  dims_swapped = compute_swapped_dims(dims, swaps)
  dims_restricted = dims_swapped[1:n]
  d = prod(dims_restricted)
  R = spzeros(Int,d,d)
  for i = 1:d
    values_restricted = unindex(dims_restricted, i)
    values = extend(values_restricted, swaps, length(dims))
    if test(values) == c
      R[i,i] = 1
    end
  end
  for dim in dims_swapped[n+1:end]
    R = kron(R,I(dim))
  end
  K = compute_swaps_operator(dims, swaps)
  return K * R * K 
end

"""
    P(dims, test, c)

    Filter operator

Compute the filter operator filtering states in which expression e
evaluates to value `c`, where `c` is `true` or `false`. Function `test`
is used to evaluate the expression e given values of all variables.
   
"""
function P(dims::Array{Int,1}, test::Function, c::Int)
  d = prod(dims)
  R = spzeros(Int,d,d)
  for i = 1:d
    values = unindex(dims, i)
    if test(values) == c
      R[i,i] = 1
    end
  end
  return R
end


#--------------------------------------------------------------------
# Auxiliary functions used to analyse the state vector 
#--------------------------------------------------------------------

#= 
 The state vector of a given pWhile program very often has large 
 dimensions and quite a few non zero entries. It is usually 
 hard to deduce anything form it by just looking at it.
 However, one frequently needs to know the probabilties 
 of some variables having certain values. The `find_probability`
 function enables one to compute that easily. . 
=#

function match(values::Array{Int,1}, expected_values::Array{Int,1})
  @assert length(values) == length(expected_values)
  for i = 1:length(values)
    if expected_values[i] != 0 && expected_values[i] != values[i]
      return false
    end
  end
  return true
end

"""
    find_probability(dims, block, state_vector, expected_values)

    Retrieve the probability of variables having values given
    by `expected_values` given `state_vector`

As usual, `dims` is an array holding ordered dimensions of variables.
`state_vector` is the distribution of the probabilistic state of 
the program. Finally, `expected_values` is an array specifying 
expected values of variables (where as usual values are given as 
indices into variable's range). The length of this array should be the 
same as the length of `dims` and each entry should be smaller or equal 
than the corresponding entry in `dims` (since a variable must take a value
in its range). Moreover, expected value of any variable can be set to 0
to denote that this variable may take any value in its range (this is 
useful since in most cases we only care about some subset of variables)

# Example
```julia
julia> find_probability([2,2],[1//2,0,0,0,1//2,0,0,0],[1,1])
1//2

julia> find_probability([2,2],[1//5,0,1//5,1//5,2//5,0,0,0],[1,0])
3//5
```
"""
function find_probability(dims::Array{Int,1}, state_vector, expected_values::Array{Int,1})
  d = prod(dims) 
  blocks = div(length(state_vector), d)
  result = 0
  for i = 1:d
    values = unindex(dims, i)
    if match(values, expected_values)
      for j = 1:blocks
        result += state_vector[(i-1) * blocks + j]
      end
    end
  end
  return result
end

1;
