# LOS.jl

#=
 This file contains functions used by julia files generated by pWhile 
 compiler. Most of the naming conventions used in this file are 
 inspired by the paper `Probabilistic Semantics and Program Analysis` 
 by A.D.Pierro, C.Hankin and H.Wiklicky. Some references to this paper
 are also made throught the comments in this code.
 
=#

#--------------------------------------------------------------------
# Auxiliary functions
#--------------------------------------------------------------------

"""
    I(dim)  

Return sparse identity matrix of dimension `dim`
"""
function I(dim)
  return speye(Int, dim)
end

"""
    E(dim, i, j)

Return sparse matrix with `ij`-entry 1, others 0, dimension `dim`
"""
function E(dim, i, j)
  @assert valid_index(dim, i) && valid_index(dim, j)
  R = spzeros(dim, dim)
  R[i,j] = 1
  return R
end

"""
    E(dim, i)

Return sparse matrix with `i`th diagonal entry 1, others 0, dimension `dim`
"""
function E(dim, i)
  return E(dim, i , i)
end

"""
    U_c(dim,c)

Return sparse matrix of dimension `dim` with entries
in `c`th column 1, otherwise 0
"""
function U_c(dim,c) 
  @assert valid_index(dim, c)
  R = spzeros(dim, dim)
  for i = 1:dim
    R[i,c] = 1
  end
  return R
end

"""
    e_i(dim,i)

Return a vector of dimension `dim` (ie a 1x`dim` matrix) with a one at 
position `i`, zeros otheriwse
"""
function e_i(dim,i)
  @assert valid_index(dim, i)
  R = spzeros(1, dim)
  R[i] = 1
  return R
end

"""
    findall(lookedfor, target)

Find all indices of elements from 'lookedfor' in 'target'

# Examples
```julia 
julia> findall([1,3], [1,2,3,4])
2-element Array{Any,1}:
 1
 3

julia> findall([2,3,4],[1,3,5])
1-element Array{Any,1}:
 2
```
"""
# NOT USED CURRENTLY - USED ONLY WHEN Ur USED
function findall(lookedfor, target)
  @assert issorted(lookedfor) && issorted(target)
  i, j = 1, 1
  result = []
  while i <= length(lookedfor) && lookedfor[i] <= target[end]
    if lookedfor[i] > target[j]
      j += 1
    elseif lookedfor[i] < target[j]
      i += 1
    else 
      push!(result, j)
      i += 1
      j += 1
    end
  end
  result
end


#=
State of variables in a program can be represented twofold.
Firstly, it could be an array specifying value of each variable
(i.e. value of ith variable is at position i in the array) - this 
is the representation described in the paper.
Alternatively, it could be represented by a single integer value 
between 1 and d (inclusive), where d is the number of different states.
Now clearly there's an isomorphism between the two representations.

# Example
Suppose there are two variables, x and y, both can take 2 different values
(it doesn't matter what those values are). Then the isomorphism is:
```julia
                        [1,1] <-> 1
                        [1,2] <-> 2
                        [2,1] <-> 3
                        [2,2] <-> 4
```
index and unindex provide the mapping between the two representations.
  - index tranforms state represented by array of values of variables into
    state represented by an integer 
  - unindex does the opposite
=#

"""
    unindex(dims, i)

Return array representation of the state of the variables corresponding
to the integer representation `i`

# Example
```julia
julia> unindex([2,2], 3)
2-element Array(Int64,1}:
 2
 1
```
"""
function unindex(dims::Array{Int,1}, i::Int) 
  @assert i <= prod(dims)
  result::Array{Int,1} = []
  if length(dims) > 1
    result = unindex(dims[1:end-1] ,div(i - 1, dims[end]) + 1)
  end
  push!(result, rem(i - 1, dims[end]) + 1)
  return result
end

"""
    index(dims, values)

Return integer representation of the state of the variables corresponding
to the array representation `values`

# Example
```julia
julia> index([2,2], [2,1])
 3
```
"""
function index(dims::Array{Int,1}, values::Array{Int,1})
  @assert length(dims) == length(values)
  for i=1:length(dims)
    @assert dims[i] >= values[i]
  end
  if length(dims) == 1
    return values[1]
  else 
    return (values[1] - 1) * prod(dims[2:end]) + index(dims[2:end], values[2:end])
  end
end

function valid_index(dim, i)
  return i > 0 && i <= dim
end

#--------------------------------------------------------------------
# State update operators and filter operators
#--------------------------------------------------------------------

function U_xk_c(dims, k, c) 
  @assert c > 0 && c <= dims[k]
  R = I(1)
  for i = 1:(k - 1)
    R = kron(R, I(dims[i]))
  end
  R = kron(R, U_c(dims[k],c))
  for i = (k + 1):length(dims)
    R = kron(R, I(dims[i]))
  end
  return R
end

function Ue(dims::Array{Int,1}, ordinal::Int, update::Function)
  @assert ordinal <= length(dims)
  d = prod(dims)
  R = spzeros(d,d)
  for i = 1:d
    values = unindex(dims, i)
    values[ordinal] = update(values) # might be that the value computed here
                                     # falls out of range (so is 0)
    if values[ordinal] > 0
      R[i,index(dims, values)] = 1
    end
  end
  return R
end

function Ur(dims::Array{Int,1}, ordinal::Int, 
           range::Array{Int,1}, assign_range::Array{Int,1})
  d = prod(dims)
  values = findall(assign_range, range)
  result = spzeros(d,d)
  for i in values
    result += Uc(dims, ordinal, i)
  end
  return 1//length(values) * result
end

function P(dims::Array{Int,1}, values::Array{Int,1}) 
  @assert length(dims) == length(values)
  R = I(1)
  for i = 1:length(dims)
    R = kron(R, E(dims[i], values[i]))
  end
  return R
end

function P(dims::Array{Int,1}, test::Function, c::Bool)
  d = prod(dims)
  R = spzeros(d,d)
  for i = 1:d
    values = unindex(dims, i)
    if test(values) == c
      R += P(dims, values)
    end
  end
  return R
end

1;
